diff --git a/src/mixer/MixerList.hxx b/src/mixer/MixerList.hxx
index e62604ce2..2a28426f3 100644
--- a/src/mixer/MixerList.hxx
+++ b/src/mixer/MixerList.hxx
@@ -27,6 +27,7 @@
 
 struct MixerPlugin;
 
+extern const MixerPlugin volfile_mixer_plugin;
 extern const MixerPlugin null_mixer_plugin;
 extern const MixerPlugin software_mixer_plugin;
 extern const MixerPlugin alsa_mixer_plugin;
diff --git a/src/mixer/plugins/VolfileMixerPlugin.cxx b/src/mixer/plugins/VolfileMixerPlugin.cxx
new file mode 100644
index 000000000..3b0ffcb82
--- /dev/null
+++ b/src/mixer/plugins/VolfileMixerPlugin.cxx
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2003-2018 The Music Player Daemon Project
+ * http://www.musicpd.org
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config/Block.hxx"
+#include "mixer/MixerInternal.hxx"
+#include "util/Domain.hxx"
+#include "Log.hxx"
+#include <string.h>
+
+static constexpr Domain volfile_mixer_domain("volfile_mixer");
+
+class VolfileMixer final : public Mixer {
+	/**
+	 * The current volume in percent (0..100).
+	 */
+	unsigned last_volume;
+
+	const char *volfile = "";
+
+public:
+	VolfileMixer(MixerListener &_listener)
+		:Mixer(volfile_mixer_plugin, _listener),
+		 last_volume(75)
+	{
+	}
+
+	/* virtual methods from class Mixer */
+	void Open() override {
+	    	last_volume = GetVolume ();
+	}
+
+	void Close() noexcept override {
+	}
+
+	int GetVolume() override {
+		int vol;
+
+		if (strlen(volfile) == 0)
+			return last_volume;
+
+		FILE *fd = fopen (volfile, "r");
+		if (fd == NULL)
+		{
+			FormatError (volfile_mixer_domain, "Failed to open volume control %s %d", volfile, errno);
+			return last_volume;
+	    	}
+
+		if (fscanf (fd, "%d", &vol) != 1)
+			return last_volume;
+
+	    	fclose (fd);
+
+	    	return (last_volume = vol);
+	};
+
+	void SetVolume(unsigned _volume) override {
+	    	char out[20];
+
+	    	if (_volume == last_volume)
+			return;
+
+	    	if (strlen(volfile) == 0)
+			return;
+
+	    	FILE *fd = fopen (volfile, "w+");
+	    	if (fd == NULL)
+	    	{
+			FormatError (volfile_mixer_domain, "Failed to open volume control %s", volfile);
+			return;
+	    	}
+
+		sprintf (out, "%d", _volume);
+	    	if (fwrite (out, strlen(out), 1, fd) == 0)
+	    	{
+			FormatError (volfile_mixer_domain, "Failed to write volume control %s", volfile);
+			return;
+	    	}
+
+	    	last_volume = _volume;
+
+	    	fclose (fd);
+	}
+
+	void Configure(const ConfigBlock &block)
+	{
+		volfile = block.GetBlockValue("volume_file", "");
+	}
+};
+
+static Mixer *
+volfile_mixer_init(gcc_unused EventLoop &event_loop,
+		gcc_unused AudioOutput &ao,
+		MixerListener &listener,
+		const ConfigBlock &block)
+{
+	VolfileMixer *mixer = new VolfileMixer(listener);
+	mixer->Configure(block);
+	return mixer;
+}
+
+const MixerPlugin volfile_mixer_plugin = {
+	volfile_mixer_init,
+	true,
+};
diff --git a/src/mixer/plugins/meson.build b/src/mixer/plugins/meson.build
index eda7c8e2a..bb70828b8 100644
--- a/src/mixer/plugins/meson.build
+++ b/src/mixer/plugins/meson.build
@@ -34,6 +34,8 @@ if is_windows
   mixer_plugins_sources += 'WinmmMixerPlugin.cxx'
 endif
 
+mixer_plugins_sources += 'VolfileMixerPlugin.cxx'
+
 mixer_plugins = static_library(
   'mixer_plugins',
   mixer_plugins_sources,
diff --git a/src/output/plugins/FifoOutputPlugin.cxx b/src/output/plugins/FifoOutputPlugin.cxx
index e7c688357..18e24548b 100644
--- a/src/output/plugins/FifoOutputPlugin.cxx
+++ b/src/output/plugins/FifoOutputPlugin.cxx
@@ -27,6 +27,7 @@
 #include "util/RuntimeError.hxx"
 #include "Log.hxx"
 #include "open.h"
+#include "mixer/MixerList.hxx"
 
 #include <sys/stat.h>
 #include <errno.h>
@@ -236,5 +237,5 @@ const struct AudioOutputPlugin fifo_output_plugin = {
 	"fifo",
 	nullptr,
 	&FifoOutput::Create,
-	nullptr,
+	&volfile_mixer_plugin,
 };
diff --git a/src/output/plugins/PipeOutputPlugin.cxx b/src/output/plugins/PipeOutputPlugin.cxx
index 2ad3d5ff6..e065f9584 100644
--- a/src/output/plugins/PipeOutputPlugin.cxx
+++ b/src/output/plugins/PipeOutputPlugin.cxx
@@ -20,6 +20,8 @@
 #include "PipeOutputPlugin.hxx"
 #include "../OutputAPI.hxx"
 #include "system/Error.hxx"
+#include "mixer/MixerList.hxx"
+
 
 #include <string>
 #include <stdexcept>
@@ -78,5 +80,5 @@ const struct AudioOutputPlugin pipe_output_plugin = {
 	"pipe",
 	nullptr,
 	&PipeOutput::Create,
-	nullptr,
+	&volfile_mixer_plugin,
 };
diff --git a/src/output/plugins/RecorderOutputPlugin.cxx b/src/output/plugins/RecorderOutputPlugin.cxx
index 194aa080e..4be086204 100644
--- a/src/output/plugins/RecorderOutputPlugin.cxx
+++ b/src/output/plugins/RecorderOutputPlugin.cxx
@@ -30,6 +30,12 @@
 #include "fs/io/FileOutputStream.hxx"
 #include "util/Domain.hxx"
 #include "util/ScopeExit.hxx"
+#include "Partition.hxx"
+#include "Instance.hxx"
+#include "Main.hxx"
+
+#include "output/MultipleOutputs.hxx"
+#include "output/State.hxx"
 
 #include <stdexcept>
 #include <memory>
@@ -57,6 +63,8 @@ class RecorderOutput final : AudioOutput {
 	 */
 	std::string format_path;
 
+	AllocatedPath archive_path = nullptr;
+
 	/**
 	 * The #AudioFormat that is currently active.  This is used
 	 * for switching to another file.
@@ -88,6 +96,7 @@ private:
 
 	size_t Play(const void *chunk, size_t size) override;
 
+	void archiveCurrent();
 private:
 	gcc_pure
 	bool HasDynamicPath() const noexcept {
@@ -103,6 +112,15 @@ private:
 
 	void FinishFormat();
 	void ReopenFormat(AllocatedPath &&new_path);
+
+	/* parent (true) recorder to send archive message to */
+	AudioOutputControl *rp;
+	RecorderOutput *parent;
+	int is_archive_recorder = 0;
+	int archive_requested = 0;
+	int can_archive = 0;
+	int delete_after_record = 0;
+	std::string archive_format_path;
 };
 
 RecorderOutput::RecorderOutput(const ConfigBlock &block)
@@ -111,6 +129,22 @@ RecorderOutput::RecorderOutput(const ConfigBlock &block)
 {
 	/* read configuration */
 
+	const char *parentName = block.GetBlockValue("parent", nullptr);
+	if (parentName != nullptr)
+	{
+		is_archive_recorder = 1;
+
+		rp = instance->partitions.front().outputs.FindByName (parentName);
+		parent = (RecorderOutput*)rp;
+
+		if (rp)
+			FormatDebug(recorder_domain, "found parent");
+		else
+			throw std::runtime_error("No such output");
+
+		return;
+	}
+ 
 	path = block.GetPath("path");
 
 	const char *fmt = block.GetBlockValue("format_path", nullptr);
@@ -122,6 +156,16 @@ RecorderOutput::RecorderOutput(const ConfigBlock &block)
 
 	if (!path.IsNull() && fmt != nullptr)
 		throw std::runtime_error("Cannot have both 'path' and 'format_path'");
+
+	const char *archive_fmt = block.GetBlockValue("archive_path", nullptr);
+	if (archive_fmt != nullptr) {
+		archive_format_path = archive_fmt;
+	}
+
+	if (block.GetBlockValue("delete_after_record", nullptr))
+		delete_after_record = 1;
+
+ 	/* initialize encoder */
 }
 
 inline void
@@ -135,6 +179,16 @@ RecorderOutput::EncoderToFile()
 void
 RecorderOutput::Open(AudioFormat &audio_format)
 {
+	if (is_archive_recorder) {
+		FormatDebug(recorder_domain, "Sending Archive Message");
+
+		parent->archiveCurrent();
+
+		// XXX TODO disable this output immedeately here
+
+		return;
+	}
+
 	/* create the output file */
 
 	if (!HasDynamicPath()) {
@@ -180,6 +234,9 @@ RecorderOutput::Commit()
 {
 	assert(!path.IsNull());
 
+	if (is_archive_recorder)
+		return;
+
 	/* flush the encoder and write the rest to the file */
 
 	try {
@@ -190,6 +247,8 @@ RecorderOutput::Commit()
 		throw;
 	}
 
+
+
 	/* now really close everything */
 
 	delete encoder;
@@ -201,6 +260,36 @@ RecorderOutput::Commit()
 		throw;
 	}
 
+	/* move file to archive if requested */
+	if (archive_requested && can_archive) {
+		std::string cmd;
+
+		if (delete_after_record)
+			cmd = "mv -- '";
+		else
+			cmd = "cp -- '";
+
+		cmd += path.c_str();
+		cmd += "' '";
+		cmd += archive_path.c_str();
+		cmd += "'&";
+
+		FormatDebug(recorder_domain, "Archiving: \"%s\"", cmd.c_str());
+
+		system (cmd.c_str());
+
+		archive_requested = 0;
+	}
+	else
+	{
+	    /* delete file if requested */
+	    if (delete_after_record) {
+		    FormatDebug(recorder_domain, "Deleting \"%s\"", path.c_str());
+		    
+		    unlink(path.c_str());
+	    }
+	}
+
 	delete file;
 }
 
@@ -282,9 +371,17 @@ RecorderOutput::ReopenFormat(AllocatedPath &&new_path)
 		    path.ToUTF8().c_str());
 }
 
+inline void RecorderOutput::archiveCurrent()
+{
+	archive_requested = 1;
+}
+
 void
 RecorderOutput::SendTag(const Tag &tag)
 {
+	if (is_archive_recorder)
+		return;
+
 	if (HasDynamicPath()) {
 		char *p = FormatTag(tag, format_path.c_str());
 		if (p == nullptr || *p == 0) {
@@ -317,6 +414,20 @@ RecorderOutput::SendTag(const Tag &tag)
 				return;
 			}
 		}
+
+		can_archive = 0;
+
+		if (!archive_format_path.empty()) {
+			char *ap = FormatTag(tag, archive_format_path.c_str());
+			AtScopeExit(ap) { free(ap); };
+
+			try {
+				archive_path = ParsePath(ap);
+				can_archive = 1;
+			} catch (const std::runtime_error &e) {
+				LogError(e);
+			}
+		}
 	}
 
 	encoder->PreTag();
@@ -327,6 +438,9 @@ RecorderOutput::SendTag(const Tag &tag)
 size_t
 RecorderOutput::Play(const void *chunk, size_t size)
 {
+	if (is_archive_recorder)
+		return size;
+
 	if (file == nullptr) {
 		/* not currently encoding to a file; discard incoming
 		   data */
