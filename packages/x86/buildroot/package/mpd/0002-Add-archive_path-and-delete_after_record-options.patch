From 347b2c5ffe822d281573ccfd7937bf2314907eb4 Mon Sep 17 00:00:00 2001
From: fesc2000 <fesc2000@gmail.com>
Date: Sun, 22 Mar 2020 05:17:40 -0400
Subject: [PATCH 2/2] Add "archive_path" and "delete_after_record" options.

Save and discard current song, unless a child plugin instance signals to store it persistently when title ends.
Implemented via new Signal() method on output controller.
---
 src/output/Control.cxx                      |  11 ++
 src/output/Control.hxx                      |  17 ++-
 src/output/Filtered.cxx                     |   6 +
 src/output/Filtered.hxx                     |   2 +
 src/output/Interface.hxx                    |   2 +
 src/output/Thread.cxx                       |  25 +++++
 src/output/plugins/RecorderOutputPlugin.cxx | 167 +++++++++++++++++++++++++++-
 7 files changed, 228 insertions(+), 2 deletions(-)

diff --git a/src/output/Control.cxx b/src/output/Control.cxx
index 45b1b6429..ceb53e83c 100644
--- a/src/output/Control.cxx
+++ b/src/output/Control.cxx
@@ -381,3 +381,14 @@ AudioOutputControl::BeginDestroy() noexcept
 		CommandAsync(Command::KILL);
 	}
 }
+
+void
+AudioOutputControl::Signal(intptr_t sig) noexcept
+{
+	const std::lock_guard<Mutex> protect(mutex);
+
+	signal = sig;
+
+	if (IsOpen())
+		CommandAsync(Command::SIGNAL);
+}
diff --git a/src/output/Control.hxx b/src/output/Control.hxx
index 3a961c57c..a271f4357 100644
--- a/src/output/Control.hxx
+++ b/src/output/Control.hxx
@@ -144,7 +144,9 @@ class AudioOutputControl {
 		DRAIN,
 
 		CANCEL,
-		KILL
+		KILL,
+
+		SIGNAL,
 	} command = Command::NONE;
 
 	/**
@@ -218,6 +220,11 @@ class AudioOutputControl {
 	 */
 	bool skip_delay;
 
+	/** 
+	 * The signal sent with Signal()
+	 */
+	intptr_t signal = 0;
+
 public:
 	/**
 	 * This mutex protects #open, #fail_timer, #pipe.
@@ -423,6 +430,11 @@ public:
 	 */
 	void LockAllowPlay() noexcept;
 
+	/**
+	 * Send an output specific signal
+	 */
+	void Signal(intptr_t info = 0) noexcept;
+
 private:
 	/**
 	 * An error has occurred and this output is defunct.
@@ -530,6 +542,9 @@ private:
 	 */
 	void InternalDrain() noexcept;
 
+	bool InternalSignal(intptr_t info) noexcept;
+
+
 	/**
 	 * The OutputThread.
 	 */
diff --git a/src/output/Filtered.cxx b/src/output/Filtered.cxx
index cbefcdbc9..beb5d45d0 100644
--- a/src/output/Filtered.cxx
+++ b/src/output/Filtered.cxx
@@ -68,6 +68,12 @@ FilteredAudioOutput::Disable() noexcept
 	output->Disable();
 }
 
+bool
+FilteredAudioOutput::Signal(intptr_t info) noexcept
+{
+	return output->Signal(info);
+}
+
 void
 FilteredAudioOutput::ConfigureConvertFilter()
 {
diff --git a/src/output/Filtered.hxx b/src/output/Filtered.hxx
index d01d6ef20..53ab27473 100644
--- a/src/output/Filtered.hxx
+++ b/src/output/Filtered.hxx
@@ -218,6 +218,8 @@ public:
 	 */
 	void CloseSoftwareMixer() noexcept;
 
+	bool Signal(intptr_t info = 0) noexcept;
+
 	gcc_pure
 	std::chrono::steady_clock::duration Delay() noexcept;
 
diff --git a/src/output/Interface.hxx b/src/output/Interface.hxx
index 565c31b77..4990fd8a5 100644
--- a/src/output/Interface.hxx
+++ b/src/output/Interface.hxx
@@ -188,6 +188,8 @@ public:
 		/* fail because this method is not implemented */
 		return false;
 	}
+
+	virtual bool Signal(intptr_t sig = 0) {(void)sig; return false;}
 };
 
 #endif
diff --git a/src/output/Thread.cxx b/src/output/Thread.cxx
index 295035665..712cf5abc 100644
--- a/src/output/Thread.cxx
+++ b/src/output/Thread.cxx
@@ -111,6 +111,24 @@ AudioOutputControl::InternalEnable() noexcept
 	}
 }
 
+inline bool
+AudioOutputControl::InternalSignal(intptr_t info) noexcept
+{
+	if (!really_enabled)
+		return false;
+
+	try {
+		{
+			const ScopeUnlock unlock(mutex);
+			return output->Signal(info);
+		}
+	} catch (...) {
+		LogError(std::current_exception());
+		Failure(std::current_exception());
+		return false;
+	}
+}
+
 inline void
 AudioOutputControl::InternalDisable() noexcept
 {
@@ -508,6 +526,13 @@ AudioOutputControl::Task() noexcept
 			source.Cancel();
 			CommandFinished();
 			return;
+
+		case Command::SIGNAL:
+			if (open)
+				InternalSignal(signal);
+
+			CommandFinished();
+			continue;
 		}
 
 		if (open && allow_play && InternalPlay())
diff --git a/src/output/plugins/RecorderOutputPlugin.cxx b/src/output/plugins/RecorderOutputPlugin.cxx
index 194aa080e..872b59770 100644
--- a/src/output/plugins/RecorderOutputPlugin.cxx
+++ b/src/output/plugins/RecorderOutputPlugin.cxx
@@ -30,9 +30,19 @@
 #include "fs/io/FileOutputStream.hxx"
 #include "util/Domain.hxx"
 #include "util/ScopeExit.hxx"
+#include "Partition.hxx"
+#include "Instance.hxx"
+#include "Main.hxx"
+#include "thread/Thread.hxx"
+#include "thread/Name.hxx"
+
+#include "output/MultipleOutputs.hxx"
+#include "output/State.hxx"
+#include "output/Filtered.hxx"
 
 #include <stdexcept>
 #include <memory>
+#include <fstream>
 
 #include <assert.h>
 #include <stdlib.h>
@@ -57,6 +67,8 @@ class RecorderOutput final : AudioOutput {
 	 */
 	std::string format_path;
 
+	AllocatedPath archive_path = nullptr;
+
 	/**
 	 * The #AudioFormat that is currently active.  This is used
 	 * for switching to another file.
@@ -88,6 +100,7 @@ private:
 
 	size_t Play(const void *chunk, size_t size) override;
 
+	bool Signal (intptr_t info);
 private:
 	gcc_pure
 	bool HasDynamicPath() const noexcept {
@@ -103,14 +116,47 @@ private:
 
 	void FinishFormat();
 	void ReopenFormat(AllocatedPath &&new_path);
+
+	void ArchiveTask();
+
+	/* parent (true) recorder to send archive message to */
+	AudioOutputControl *parent;
+	int is_archive_recorder = 0;
+	int archive_requested = 0;
+	int can_archive = 0;
+	int delete_after_record = 0;
+	std::string archive_format_path;
+	Thread archive_thread;
+	char *archive_source = NULL;
+	char *archive_dest = NULL;
 };
 
 RecorderOutput::RecorderOutput(const ConfigBlock &block)
 	:AudioOutput(0),
-	 prepared_encoder(CreateConfiguredEncoder(block))
+	 prepared_encoder(CreateConfiguredEncoder(block)),
+	 archive_thread(BIND_THIS_METHOD(ArchiveTask))
 {
 	/* read configuration */
 
+	const char *parentName = block.GetBlockValue("parent", nullptr);
+	if (parentName != nullptr)
+	{
+		is_archive_recorder = 1;
+
+		parent = instance->partitions.front().outputs.FindByName (parentName);
+
+		if (parent)
+		{
+			FormatDebug(recorder_domain, "found parent");
+		}
+		else
+		{
+			throw std::runtime_error("No such output");
+		}
+
+		return;
+	}
+ 
 	path = block.GetPath("path");
 
 	const char *fmt = block.GetBlockValue("format_path", nullptr);
@@ -122,6 +168,16 @@ RecorderOutput::RecorderOutput(const ConfigBlock &block)
 
 	if (!path.IsNull() && fmt != nullptr)
 		throw std::runtime_error("Cannot have both 'path' and 'format_path'");
+
+	const char *archive_fmt = block.GetBlockValue("archive_path", nullptr);
+	if (archive_fmt != nullptr) {
+		archive_format_path = archive_fmt;
+	}
+
+	if (block.GetBlockValue("delete_after_record", nullptr))
+		delete_after_record = 1;
+
+ 	/* initialize encoder */
 }
 
 inline void
@@ -135,6 +191,14 @@ RecorderOutput::EncoderToFile()
 void
 RecorderOutput::Open(AudioFormat &audio_format)
 {
+	if (is_archive_recorder) {
+		FormatDebug(recorder_domain, "Sending Archive Message");
+
+		parent->Signal(0);
+
+		return;
+	}
+
 	/* create the output file */
 
 	if (!HasDynamicPath()) {
@@ -178,6 +242,9 @@ RecorderOutput::Open(AudioFormat &audio_format)
 inline void
 RecorderOutput::Commit()
 {
+	if (is_archive_recorder)
+		return;
+
 	assert(!path.IsNull());
 
 	/* flush the encoder and write the rest to the file */
@@ -190,6 +257,7 @@ RecorderOutput::Commit()
 		throw;
 	}
 
+
 	/* now really close everything */
 
 	delete encoder;
@@ -201,10 +269,79 @@ RecorderOutput::Commit()
 		throw;
 	}
 
+	/* move file to archive if requested */
+	if (archive_requested && can_archive) {
+
+		// wait for previous move operation to finish
+		if (archive_thread.IsDefined())
+			archive_thread.Join();
+
+		// run move/copy asynchronously to not block output operation
+		//
+		archive_source = strdup(path.c_str());
+		archive_dest = strdup(archive_path.c_str());
+
+		archive_thread.Start();
+
+		archive_requested = 0;
+	}
+	else
+	{
+	    /* delete file if requested */
+	    if (delete_after_record) {
+		    FormatDebug(recorder_domain, "Deleting \"%s\"", path.c_str());
+		    
+		    unlink(path.c_str());
+	    }
+	}
+
 	delete file;
 }
 
 void
+RecorderOutput::ArchiveTask() {
+	int rc;
+
+	SetThreadName("archive_file");
+
+	if (!archive_source || !archive_dest)
+		return;
+
+	if (delete_after_record) {
+		rc = rename (archive_source, archive_dest);
+	} else {
+		try {
+			std::ifstream  src(archive_source, std::ios::binary);
+			std::ofstream  dst(archive_dest,   std::ios::binary);
+
+			dst << src.rdbuf();
+
+			rc = 0;
+		} 
+		catch(...)
+		{
+			rc = -1;
+		}
+	}
+
+	if (rc == 0) {
+		FormatDebug(recorder_domain, "%s \"%s\" to \"%s\"",
+			delete_after_record ? "Moved" : "Copied",
+			archive_source, archive_dest);
+	} else {
+		FormatError(recorder_domain, "Failed to %s \"%s\" to \"%s\", rc=%d",
+			delete_after_record ? "move" : "copy",
+			archive_source, archive_dest, errno);
+	}
+
+
+	free (archive_source);
+	free (archive_dest);
+
+	archive_source = archive_dest = NULL;
+}
+
+void
 RecorderOutput::Close() noexcept
 {
 	if (file == nullptr) {
@@ -282,9 +419,20 @@ RecorderOutput::ReopenFormat(AllocatedPath &&new_path)
 		    path.ToUTF8().c_str());
 }
 
+inline bool RecorderOutput::Signal(intptr_t sig)
+{
+	(void)sig;
+	archive_requested = 1;
+
+	return true;
+}
+
 void
 RecorderOutput::SendTag(const Tag &tag)
 {
+	if (is_archive_recorder)
+		return;
+
 	if (HasDynamicPath()) {
 		char *p = FormatTag(tag, format_path.c_str());
 		if (p == nullptr || *p == 0) {
@@ -317,6 +465,20 @@ RecorderOutput::SendTag(const Tag &tag)
 				return;
 			}
 		}
+
+		can_archive = 0;
+
+		if (!archive_format_path.empty()) {
+			char *ap = FormatTag(tag, archive_format_path.c_str());
+			AtScopeExit(ap) { free(ap); };
+
+			try {
+				archive_path = ParsePath(ap);
+				can_archive = 1;
+			} catch (const std::runtime_error &e) {
+				LogError(e);
+			}
+		}
 	}
 
 	encoder->PreTag();
@@ -327,6 +489,9 @@ RecorderOutput::SendTag(const Tag &tag)
 size_t
 RecorderOutput::Play(const void *chunk, size_t size)
 {
+	if (is_archive_recorder)
+		return size;
+
 	if (file == nullptr) {
 		/* not currently encoding to a file; discard incoming
 		   data */
-- 
2.11.0

