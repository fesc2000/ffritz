diff --git a/plugins/irtoy.c b/plugins/irtoy.c
index 1183810..173e555 100644
--- a/plugins/irtoy.c
+++ b/plugins/irtoy.c
@@ -194,6 +194,8 @@ read_with_timeout(int fd, void* buf, size_t count, long to_usec)
 	ssize_t rc;
 	size_t numread = 0;
 	struct pollfd pfd = {.fd = fd, .events = POLLIN, .revents = 0};
+	struct stat st;
+	int loop = 0;
 
 	rc = read(fd, (char*)buf, count);
 
@@ -201,6 +203,7 @@ read_with_timeout(int fd, void* buf, size_t count, long to_usec)
 		numread += rc;
 
 	while ((rc == -1 && errno == EAGAIN) || (rc >= 0 && numread < count)) {
+		loop++;
 
 		rc = curl_poll(&pfd, 1, to_usec / 1000);
 
@@ -211,10 +214,26 @@ read_with_timeout(int fd, void* buf, size_t count, long to_usec)
 			/* continue for EAGAIN case */
 			continue;
 
+		errno = 0;
 		rc = read(fd, ((char*)buf) + numread, count - numread);
 
-		if (rc > 0)
+		if (rc > 0) {
 			numread += rc;
+			loop = 0;
+		}
+		else if ((errno == ENXIO) ||
+			 (fstat (fd, &st) == -1) ||
+			 (loop > 50)) {
+			/* This is what happens if i unplug irtoy at runtime:
+			 * - poll (select variant) returns successfully,
+			 * - fstat succeeds (/dev/ttyACM0 still exists (?)
+			 * - Read returns 0 (no error, would expect ENXIO)
+			 * -> endless loop at full CPU load (terminated after 50 here)
+			 */
+			log_error("irtoy: Hardware disconnect? Exiting. (loop=%d, %s)\n",
+				loop, strerror(errno));
+			exit (1);
+		}
 	}
 	return (numread == 0) ? -1 : numread;
 }
